name: Build Monorepo Apps

on:
  workflow_call:
    inputs:
      apps_config:
        description: 'JSON array of app configurations [{name, path, dockerfile?, build_args?}]'
        required: true
        type: string
      registry:
        description: 'Container registry URL'
        required: true
        type: string
      image_prefix:
        description: 'Image name prefix (e.g., herrewijnen)'
        required: true
        type: string
      build_all:
        description: 'Force build all apps regardless of changes'
        required: false
        type: boolean
        default: false
      image_tag:
        description: 'Custom image tag (overrides default semver pre-release pattern)'
        required: false
        type: string
    secrets:
      GCP_WORKLOAD_IDENTITY_PROVIDER:
        description: 'GCP Workload Identity Provider'
        required: true
      GCP_SERVICE_ACCOUNT:
        description: 'GCP Service Account email'
        required: true
      CONTENTFUL_SPACE_ID:
        description: 'Contentful Space ID (optional)'
        required: false
      CONTENTFUL_ACCESS_TOKEN:
        description: 'Contentful Access Token (optional)'
        required: false
      NEXT_PUBLIC_GOOGLE_MAPS_KEY:
        description: 'Google Maps API Key (optional)'
        required: false
      NEXT_PUBLIC_GA_ID:
        description: 'Google Analytics ID (optional)'
        required: false
      GOOGLE_PLACE_ID:
        description: 'Google Place ID (optional)'
        required: false
    outputs:
      built_images:
        description: 'JSON object of built images {app_name: image_url}'
        value: ${{ jobs.summary.outputs.built_images }}
      image_tag:
        description: 'The image tag used (semver pre-release format)'
        value: ${{ jobs.version.outputs.image_tag }}

jobs:
  version:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}
      next_version: ${{ steps.version.outputs.next_version }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine next version
        id: version
        run: |
          # Try to get current version from various sources
          if [ -f ".release-please-manifest.json" ]; then
            CURRENT_VERSION=$(jq -r '.["."]' .release-please-manifest.json 2>/dev/null || echo "0.0.0")
          elif [ -f "package.json" ]; then
            CURRENT_VERSION=$(jq -r '.version // "0.0.0"' package.json)
          elif [ -f "VERSION" ]; then
            CURRENT_VERSION=$(cat VERSION | tr -d '\n')
          else
            CURRENT_VERSION="0.0.0"
          fi

          # Clean version (remove 'v' prefix if present)
          CURRENT_VERSION="${CURRENT_VERSION#v}"
          echo "Current version: $CURRENT_VERSION"

          # Get commits since last tag to analyze for version bump
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -n "$LAST_TAG" ]; then
            COMMITS=$(git log $LAST_TAG..HEAD --format="%s" 2>/dev/null || git log --format="%s" -50)
          else
            COMMITS=$(git log --format="%s" -50)
          fi

          # Determine version bump based on conventional commits
          BUMP="patch"

          if echo "$COMMITS" | grep -qE "^[a-z]+(\(.+\))?!:|BREAKING CHANGE:"; then
            BUMP="major"
          elif echo "$COMMITS" | grep -qE "^feat(\(.+\))?:"; then
            BUMP="minor"
          fi

          # Calculate next version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}

          case "$BUMP" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "Next version: $NEXT_VERSION (bump: $BUMP)"

      - name: Generate image tag
        id: tag
        run: |
          # Use custom tag if provided (for releases), otherwise generate semver pre-release
          if [ -n "${{ inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ inputs.image_tag }}"
          else
            NEXT_VERSION="${{ steps.version.outputs.next_version }}"
            TIMESTAMP=$(date +%s)
            SHA_SHORT=$(echo ${{ github.sha }} | cut -c1-7)

            # Format: v0.30.1-1737451200.abc1234
            # Timestamp first ensures semver sorts chronologically
            IMAGE_TAG="v${NEXT_VERSION}-${TIMESTAMP}.${SHA_SHORT}"
          fi

          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Image tag: $IMAGE_TAG"

  detect:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.changes.outputs.matrix }}
      has_changes: ${{ steps.changes.outputs.has_changes }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed apps
        id: changes
        run: |
          APPS_CONFIG='${{ inputs.apps_config }}'

          if [ "${{ inputs.build_all }}" == "true" ]; then
            echo "Building all apps (forced)"
            MATRIX="{\"app\":$APPS_CONFIG}"
            echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get changed files
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            BASE_SHA=${{ github.event.pull_request.base.sha }}
            HEAD_SHA=${{ github.event.pull_request.head.sha }}
            CHANGED_FILES=$(git diff --name-only $BASE_SHA...$HEAD_SHA)
          else
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only HEAD)
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Check each app for changes
          CHANGED_APPS="[]"

          for app in $(echo "$APPS_CONFIG" | jq -r '.[] | @base64'); do
            APP_NAME=$(echo "$app" | base64 -d | jq -r '.name')
            APP_PATH=$(echo "$app" | base64 -d | jq -r '.path')

            if echo "$CHANGED_FILES" | grep -q "^${APP_PATH}/"; then
              CHANGED_APPS=$(echo "$CHANGED_APPS" | jq --arg name "$APP_NAME" '. + [$name]')
              echo "App changed: $APP_NAME"
            fi
          done

          # Check for root changes
          if echo "$CHANGED_FILES" | grep -qE "^(package\.json|pnpm-lock\.yaml|bun\.lockb|requirements\.txt|go\.mod|go\.sum|\.dockerignore|charts/)"; then
            echo "Root dependency change detected, building all apps"
            CHANGED_APPS=$(echo "$APPS_CONFIG" | jq '[.[].name]')
          fi

          # Create matrix
          FILTERED=$(echo "$APPS_CONFIG" | jq --argjson changed "$CHANGED_APPS" '[.[] | select(.name as $n | $changed | index($n))]')
          HAS_CHANGES=$([ "$(echo "$FILTERED" | jq 'length')" -gt 0 ] && echo "true" || echo "false")

          echo "matrix={\"app\":$FILTERED}" >> $GITHUB_OUTPUT
          echo "has_changes=$HAS_CHANGES" >> $GITHUB_OUTPUT

          echo "Matrix: {\"app\":$FILTERED}"

  build:
    needs: [version, detect]
    if: needs.detect.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect.outputs.matrix) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
          token_format: access_token

      - name: Login to Artifact Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: oauth2accesstoken
          password: ${{ steps.auth.outputs.access_token }}

      - name: Extract metadata
        id: meta
        run: |
          IMAGE_NAME="${{ inputs.image_prefix }}/${{ matrix.app.name }}"
          IMAGE_TAG="${{ needs.version.outputs.image_tag }}"
          BRANCH_TAG=$(echo "${{ github.ref_name }}" | sed 's/\//-/g')

          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_url=${{ inputs.registry }}/${IMAGE_NAME}:${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "branch_tag=${BRANCH_TAG}" >> $GITHUB_OUTPUT

      - name: Determine Dockerfile
        id: dockerfile
        run: |
          DOCKERFILE="${{ matrix.app.dockerfile }}"
          if [ -z "$DOCKERFILE" ]; then
            DOCKERFILE="Dockerfile"
          fi
          echo "path=${{ matrix.app.path }}/${DOCKERFILE}" >> $GITHUB_OUTPUT

      - name: Prepare build args
        id: build_args
        run: |
          # Start with app-specific build args
          ARGS="${{ matrix.app.build_args }}"

          # Add secrets as build args if provided
          if [ -n "${{ secrets.CONTENTFUL_SPACE_ID }}" ]; then
            ARGS="${ARGS}${ARGS:+$'\n'}CONTENTFUL_SPACE_ID=${{ secrets.CONTENTFUL_SPACE_ID }}"
          fi
          if [ -n "${{ secrets.CONTENTFUL_ACCESS_TOKEN }}" ]; then
            ARGS="${ARGS}${ARGS:+$'\n'}CONTENTFUL_ACCESS_TOKEN=${{ secrets.CONTENTFUL_ACCESS_TOKEN }}"
          fi
          if [ -n "${{ secrets.NEXT_PUBLIC_GOOGLE_MAPS_KEY }}" ]; then
            ARGS="${ARGS}${ARGS:+$'\n'}NEXT_PUBLIC_GOOGLE_MAPS_KEY=${{ secrets.NEXT_PUBLIC_GOOGLE_MAPS_KEY }}"
          fi
          if [ -n "${{ secrets.NEXT_PUBLIC_GA_ID }}" ]; then
            ARGS="${ARGS}${ARGS:+$'\n'}NEXT_PUBLIC_GA_ID=${{ secrets.NEXT_PUBLIC_GA_ID }}"
          fi
          if [ -n "${{ secrets.GOOGLE_PLACE_ID }}" ]; then
            ARGS="${ARGS}${ARGS:+$'\n'}GOOGLE_PLACE_ID=${{ secrets.GOOGLE_PLACE_ID }}"
          fi

          # Output build args (multiline safe)
          echo "args<<EOF" >> $GITHUB_OUTPUT
          echo "$ARGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.app.path }}
          file: ${{ steps.dockerfile.outputs.path }}
          push: true
          tags: |
            ${{ inputs.registry }}/${{ steps.meta.outputs.image_name }}:${{ steps.meta.outputs.image_tag }}
            ${{ inputs.registry }}/${{ steps.meta.outputs.image_name }}:${{ github.ref_name == 'main' && 'latest' || steps.meta.outputs.branch_tag }}
          build-args: ${{ steps.build_args.outputs.args }}
          cache-from: type=gha,scope=${{ matrix.app.name }}
          cache-to: type=gha,mode=max,scope=${{ matrix.app.name }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.meta.outputs.image_tag }}
            app.name=${{ matrix.app.name }}

      - name: Output image info
        run: |
          echo "Built image: ${{ steps.meta.outputs.image_url }}"

  summary:
    needs: [version, detect, build]
    if: always() && needs.detect.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    outputs:
      built_images: ${{ steps.collect.outputs.images }}

    steps:
      - name: Collect built images
        id: collect
        run: |
          IMAGE_TAG="${{ needs.version.outputs.image_tag }}"

          APPS='${{ needs.detect.outputs.matrix }}'
          IMAGES="{}"

          for app in $(echo "$APPS" | jq -r '.app[].name'); do
            IMAGE_URL="${{ inputs.registry }}/${{ inputs.image_prefix }}/${app}:${IMAGE_TAG}"
            IMAGES=$(echo "$IMAGES" | jq -c --arg name "$app" --arg url "$IMAGE_URL" '. + {($name): $url}')
          done

          echo "images=$(echo "$IMAGES" | jq -c .)" >> $GITHUB_OUTPUT
          echo "Built images:"
          echo "$IMAGES" | jq .
          echo ""
          echo "Image tag: $IMAGE_TAG"
